
This document contains a brief summary of the steps required to setup/create 
the mock observations (in the absence of an actual detection!)


1) Creating the mock observation (see (3) for light-cones)
2) Creating the error files
3) Mock observations with the observed light-cone (21cm PS only)
4) Creating the error files (light-cone)
5) Mock observation naming convention (21cm PS)
6) The global signal

______________________________________________________________________________



1) Creating the mock observation


The mock observation (i.e. 21cm PS) should be generated by calling 
drive_21cmMC_streamlined.c for the specific astrophysical parameter set and
optional flags that you would like to serve as the mock observation.

This should be generated from a larger simulation box (physical size, i.e. Mpc)
and with a different set of initial conditions! These two boxes, the mock
observation and the boxes for sampling the MCMC should have the same resolution.

When selecting the box sizes to be used in 21CMMC (the larger mock and the smaller
MCMC sampled box) make sure that in both case that the fitting scale that is
to be used as the discriminant (i.e. chi^2) is on scales that are sufficiently 
sampled (i.e. free of sample variance).

(Note, remember that for each change of L and DIM/HII_DIM in INIT_PARAMS.H the C code
must be re-compiled. Make sure the values of L and DIM/HII_DIM are set and 
compiled for the MCMC sampled values prior to starting the MCMC!)

Once these have been generated, rename the files in a naming format similar to 
how it is outlined in 21CMMC.py and for the examples provided. 




______________________________________________________________________________



2) Creating the error files


Once the mock observations have been created, the next step is creating the 
error profile (thermal and/or cosmic variance).

For the 21cm PS, I use 21cmSense (https://github.com/jpober/21cmSense). With 
this, the user can define an instrumental setup and generate thermal + sample
variance errors for a given 21cm PS (i.e. the mock observation).

However, any method to generate the errors can be used. The only thing required
is for the errors to be written in text files, with naming convention readable
by 21CMMC.py. Further, the data format should also be copied (two column file, 
first column k, second column noise).

Can refer to the example error files provided.

______________________________________________________________________________



3) Mock observations with the observed light-cone (21cm PS only)


Using the light-cone becomes a little more problematic. The default treatment 
of the light-cone in 21cmFAST/21CMMC is to generate a full 3D cuboid of the 
light-cone. That is, for a 600 Mpc, 400^3 box, this will create a 3D cuboid
with the two transverse directions being 600 Mpc, and the line-of-sight depth
being interpolated in redshift.

Now, the equivalent MCMC sampled box (e.g. 300 Mpc, 200^3 box) would have the
two transverse directions being 300 Mpc and the line-of-sight depth interpolated
in redshift.

This line-of-sight depth would be the same between the two boxes, as it is 
redshift (frequency) based.

However, to generate the 21cm PS, these cuboids are carved up into fixed box
lengths (i.e. the fiducial box length, either 300 Mpc or 600 Mpc). As such, 
the mock observation would have a factor of 2 lower number of 21cm PS, because
a 600 Mpc box would be used to generate a 21cm PS, whereas a 300 Mpc would be
used for the smaller box. Thus, 2 300 Mpc boxes per 600 Mpc box.

In order to generate the same number of 21cm PS boxes, I split the 600 Mpc boxes
into two 300 Mpc boxes. However, these are 600 x 600 x 300 Mpc boxes. Then I 
generate the 21cm PS for each of these boxes and use them as the mock 21cm PS
to be sampled by the MCMC.

To perform this splitting I created the “SplitMockObservation.c” module. Which,
following user defined arguments (see the file for details) it will read in the
larger box simulation and split it into the necessary number of smaller box 
simulations.

Finally, this is how I chose to deal with the 21cm PS from the light-cone. There
is no one unique way of doing this, therefore, the user is free to modify how 
this is done.

To be able to perform this splitting, you will need to have the 21cm brightness
temperature field from the light-cone. To obtain this, you will need to run 
drive_21cmMC_streamlined.c using the optional flag PRINT_LIGHTCONE_21cmBoxes in 
Variables.h set to 1 (remember to turn this flag off prior to commencing a full
MCMC run!).

NOTE: Read the preamble of “SplitMockObservation.c” regarding the file naming 
convention of the output files. Requires manually altering the file names, 
otherwise each subsequent call of this script will overwrite the previous outputs.

______________________________________________________________________________



4) Creating the error files (light-cone)


Don’t forget to create the error files for the light-cone 21cm PS. Again, there is
no unique way to do this. Typically, I adopt the central redshift of the 21cm
light-cone cube and generate the subsequent noise curve. Not ideal, but it is 
a reasonable approximation provided the delta-z across the box isn’t too large.


______________________________________________________________________________



5) Mock observation naming convention (21cm PS)


It might be counter intuitive, however, there are two naming conventions for 
the 21cm PS. One, for the co-eval case, one for the light-cone case.

In general, the co-eval case searches for the exact file containing the 21cm PS,
and this file contains the co-eval redshift in the file name. I find this to be
useful, as it requires the redshifts to be correct as entered in 21CMMC.py with
the generated files. 

On the other hand, for the light-cone case, 21CMMC will read from a single file
all generated 21cm PS files (e.g. LightCone21cmPS_BrightGalaxies_600Mpc_400.txt)
It will read the names of all the 21cm PS files and use these as the mock and
noise. For each sampled astrophysical parameter set, the driver 
“drive_21cmMC_streamlined.c” will output such a file, from which it will be able
to locate the necessary 21cm PS from the light-cone.

The co-eval case should probably follow the light-cone case, however, I preferred
to keep it separate to ensure 21CMMC broke when I switched from co-eval to 
light-cone if the wrong options were set.

Additionally, for the co-eval PS case, only a handful of redshifts were ever used, 
thus relatively straightforward to maintain.


______________________________________________________________________________



6) The global signal


For the global signal, steps similar to above need to be followed, however, it is
far more trivial (don’t have to be concerned with multiple 21cm PS or light-cones etc.)

Just generate the global signal from the mock observation. To do so, the AveData_* file
needs to be created. This can be created ensuring that the corresponding flag in the 
Walker_* file is set to 1.

Then, follow the file naming convention as provided in 21CMMC.

For the noise, fixed global signal noise can be added from within 21CMMC.py, otherwise, 
for variable noise, just need to have the observational noise of the global signal
readable from text file, as in the default version of 21CMMC.
